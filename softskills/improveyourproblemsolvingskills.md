Improve Your Problem-Solving Skills
Contributed by Charles Humble

Difficulty level: Intermediate

Last year I gave a conference talk called “Writing for Nerds”, where I drew parallels between writing articles like this and writing code. The reason those parallels exist is because a lot of what we do as software engineers is a mixture of creativity and problem-solving—similar to the processes involved with writing, making music, or designing something.

Strangely, when we’re taught how to program, problem-solving is rarely covered; rather, it is treated as something that future programmers should be able to figure out on their own. While an enjoyment of problem-solving is something that draws many of us to this field, it doesn’t guarantee that we have all the techniques and know-how.

There are two mistakes I frequently see people make. The first is to dive straight into the integrated development environment (IDE) and start coding. That might work, but more often than not. you’ll just end up wasting time. The second is to go straight to a search engine, Stack Overflow, or (increasingly) to a large language model (LLM), and copy and paste whatever code you find. The risk there is that not only have you not understood the solution you’re copying and pasting, but you haven’t really understood the problem either. It’s not that these tools aren’t useful, but it’s best to avoid seeing them as both the start and end of your problem-solving toolset.

Problems vary in size and scope. They might be anything from seeing a strange error message and not knowing what it means, to having a weighty business problem and no idea of how to resolve it. You’ll be able to sort out some issues straightaway—say, a syntax error at compile time or a message that says you’ve forgotten to import a package. But what approach can you take when the problem is more complex?

There is a basic four-step process you can use for almost any problem, and I usually carry out all but the last of them with pen and paper, away from my computer.

As Charles Kettering, the famed inventor and head of research for GM, famously said, “A problem well-stated is a problem half-solved”. So step one is to make sure you have identified, and can articulate, what the problem is. If you are debugging something, you might find it helpful to ask questions such as “what do you think the code should be doing?” and “what is it actually doing?”

Once you understand the problem, step two is where you start gathering information. The approach you take will vary depending on the nature of the issue. For example, if you are struggling with a particular package or API, start by looking at the documentation. If you are trying to understand why something in a company codebase has been written a particular way, try looking at the commit history and see if you can figure out what the developers were trying to achieve. If any of the developers who worked on it are still around, go and talk to them. For something like an open source project, you might find a trip through the source code interesting. It will sometimes tell you that the code isn’t doing what you thought it was, and you can learn a tremendous amount by just seeing how others solve problems.

Step three is to come up with potential solutions. Resist the temptation to go with the first idea you come up with. Instead, take the time to produce several possibilities and iterate on them. Try not to dismiss an idea at this stage, however unusable it might seem since, along with real constraints, you will also have perceived ones—things that you think are constraints but aren’t. Once you have your list, go through it and see if you can explain why a certain path can’t be taken. Are you sure it won’t work?

As part of your iteration process, consider whether you need to solve the problem at all. In my free time I write music as part of a duo called Twofish. I recently spent an entire studio session with my music partner trying to get a guitar solo to flow properly…until we realized the solo was fine and we just needed to add a couple of spot effects. In my writing, I’ve spent hours moving sentences around only to realize that I didn’t need them and that was why they didn’t seem to fit. With coding it can be similar; is there a way to bypass, rather than tackle, something intractable?

Confessional Programming and Rubber Ducks
During step three, I frequently use a technique called confessional programming, which involves explaining the problem to someone else. What is interesting about this is that it doesn’t really matter who I explain it to; I will quite often chat to a programmer friend, colleague, or perhaps my wife, but I’ve also explained complex problems to my ancient and usually fast asleep cat. This approach is sometimes called rubberducking—a reference to a story in the book The Pragmatic Programmer, in which a programmer would carry around a rubber duck and debug their code by forcing themselves to explain it, line by line, to the duck. It can be surprisingly effective because talking through a problem can reveal whether you have really understood it. It also seems to use a slightly different part of your brain, and perhaps also slows down your thinking, which can be helpful.

Step four is where you start coding your preferred solution. Be prepared to find you are going down a wrong path, and that your chosen approach is inelegant or cumbersome. Try not to get too hung up on your solution too early, and be prepared to abandon it if it doesn’t work as you expected. As part of the implementation, ensure that you test your solution, verify it, and document it as you would with any code you write.

The Importance of Doing Nothing
Solving entirely unrelated problems for fun—crossword puzzles, Sudoku, Wordle, and the like—may help keep your mind sharp. I also do as much background reading as I can, and let my brain find connections at its leisure. But keep in mind that doing nothing is actually one of the best ways to solve problems. If you are really stuck, take a break; go for a walk or a run, have a bath, sleep on it, and come back tomorrow. I’ve frequently written difficult emails, solved writing and coding problems, or come up with ideas for pieces of music while out walking. In her book, Thinking on My Feet, my sister, the writer and broadcaster Kate Humble, describes similar experiences.

The reason this works may have something to do with the default mode network. Holly Cummins, senior principal software engineer on the Red Hat Quarkus team, eloquently describes it as “a pattern of brain activity which kicks into life when the rest of the brain goes into an idle state,” which appears to have a strong connection to creativity.

It’s easy to become so focused on execution that you cannot think a problem through properly. What you need to do instead is to pull problem-solving out of that realm. You might find it helpful to think of your desk as a place of execution but not of thinking and problem-solving. There are plenty of other places you can do that.