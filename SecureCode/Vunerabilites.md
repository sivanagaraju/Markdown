Below is a comprehensive tabular output detailing ten critical web application security vulnerabilities. Each entry includes a serial number, vulnerability name, detailed description, vulnerable and secure code examples in Python and Java with explanatory comments, and additional comments for better understanding. The table is designed to be easy to follow and informative for developers aiming to secure their applications.

---

### Tabular Output of Web Application Security Vulnerabilities

| S.no | Vulnerability Name                     | Description                                                                                                   | Python Vulnerable Code                                                                                             | Python Secure Code                                                                                                 | Java Vulnerable Code                                                                                               | Java Secure Code                                                                                                   | Comments                                                                                     |
|------|----------------------------------------|---------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------|
| 1    | Command Injection (CWE-77, CWE-78)     | Command injection occurs when an application executes native commands with untrusted data, allowing attackers to run arbitrary OS commands on the server, potentially leading to system compromise or data theft. CWE-77 covers general command injection, while CWE-78 focuses on OS-specific issues. | ```python<br>import subprocess<br>import os<br>from flask import Flask, request<br><br>app = Flask(__name__)<br><br>@app.route("/dns")<br>def vulnerable_dns_lookup():<br>    hostname = request.values.get('hostname')<br>    # VULNERABLE: Concatenating user input into command string<br>    cmd = 'nslookup ' + hostname<br>    # DANGER: shell=True allows command injection (e.g., "; rm -rf /")<br>    return subprocess.check_output(cmd, shell=True)<br><br>@app.route("/file_process")<br>def vulnerable_file_process():<br>    filename = request.values.get('filename')<br>    # VULNERABLE: os.system executes raw user input<br>    os.system(f"cat {filename}")  # Attacker can input "; ls -la"<br>    return "File processed"<br>``` | ```python<br>import subprocess<br>import shlex<br>from flask import Flask, request<br><br>app = Flask(__name__)<br><br>@app.route("/dns")<br>def secure_dns_lookup():<br>    hostname = request.values.get('hostname')<br>    # SECURE: Command as a list prevents injection<br>    cmd = ['nslookup', hostname]<br>    try:<br>        # SAFE: shell=False avoids shell interpretation<br>        result = subprocess.check_output(cmd, shell=False, timeout=10)<br>        return result<br>    except subprocess.CalledProcessError:<br>        return "DNS lookup failed"<br><br>@app.route("/file_process")<br>def secure_file_process():<br>    filename = request.values.get('filename')<br>    # SECURE: Input validation<br>    if not filename or not filename.isalnum():<br>        return "Invalid filename"<br>    # SAFE: List-based command execution<br>    try:<br>        result = subprocess.run(['cat', filename], capture_output=True, shell=False, timeout=5)<br>        return result.stdout<br>    except subprocess.TimeoutExpired:<br>        return "Operation timed out"<br>``` | ```java<br>import javax.servlet.http.*;<br>import java.io.*;<br><br>public class VulnerableServlet extends HttpServlet {<br>    protected void doGet(HttpServletRequest request, HttpServletResponse response) <br>            throws ServletException, IOException {<br>        String accountNumber = request.getParameter("account");<br>        String nickname = request.getParameter("nickname");<br>        // VULNERABLE: String concatenation with user input<br>        String cmd = "/opt/account_tools/bin/make_account_pdf " + accountNumber + " \"" + nickname + "\"";<br>        // DANGER: Executes raw command (e.g., "1; rm -rf /")<br>        Runtime.getRuntime().exec(cmd);<br>        response.getWriter().println("PDF generated");<br>    }<br>}<br>``` | ```java<br>import javax.servlet.http.*;<br>import java.io.*;<br><br>public class SecureServlet extends HttpServlet {<br>    protected void doGet(HttpServletRequest request, HttpServletResponse response) <br>            throws ServletException, IOException {<br>        String accountNumber = request.getParameter("account");<br>        String nickname = request.getParameter("nickname");<br>        // SECURE: Input validation<br>        if (!isValidAccountNumber(accountNumber) || !isValidNickname(nickname)) {<br>            response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Invalid input");<br>            return;<br>        }<br>        // SAFE: ProcessBuilder with separate arguments<br>        ProcessBuilder pb = new ProcessBuilder("/opt/account_tools/bin/make_account_pdf", accountNumber, nickname);<br>        try {<br>            Process process = pb.start();<br>            process.waitFor();<br>            response.getWriter().println("PDF generated successfully");<br>        } catch (InterruptedException e) {<br>            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);<br>        }<br>    }<br>    private boolean isValidAccountNumber(String account) {<br>        return account != null && account.matches("\\d{9}");<br>    }<br>    private boolean isValidNickname(String nickname) {<br>        return nickname != null && nickname.matches("[a-zA-Z0-9 ]{1,50}");<br>    }<br>}<br>``` | - Use list-based command execution instead of string concatenation.<br>- Avoid `shell=True` in Python or `Runtime.exec` with raw strings in Java.<br>- Validate inputs strictly to prevent malicious commands. |
| 2    | Insecure Deserialization (CWE-502)     | Insecure deserialization allows attackers to execute arbitrary code or manipulate data by deserializing untrusted input, potentially causing denial-of-service or unauthorized access. This occurs when applications process serialized data without validation. | ```python<br>import pickle<br>from flask import Flask, request<br><br>app = Flask(__name__)<br><br>@app.route('/deserialize', methods=['POST'])<br>def vulnerable_deserialize():<br>    data = request.data<br>    # VULNERABLE: Untrusted data deserialized directly<br>    obj = pickle.loads(data)  # Can execute arbitrary code<br>    return str(obj)<br>``` | ```python<br>import json<br>from flask import Flask, request<br><br>app = Flask(__name__)<br><br>@app.route('/deserialize', methods=['POST'])<br>def secure_deserialize():<br>    data = request.data<br>    # SECURE: Use safe JSON deserialization<br>    try:<br>        obj = json.loads(data)  # JSON doesn't execute code<br>        return str(obj)<br>    except json.JSONDecodeError:<br>        return "Invalid data", 400<br>``` | ```java<br>import java.io.*;<br>import javax.servlet.http.*;<br><br>public class VulnerableDeserializationServlet extends HttpServlet {<br>    protected void doPost(HttpServletRequest request, HttpServletResponse response) <br>            throws ServletException, IOException {<br>        ObjectInputStream ois = new ObjectInputStream(request.getInputStream());<br>        // VULNERABLE: Deserializes untrusted input<br>        Object obj = ois.readObject();  // Can lead to code execution<br>        response.getWriter().println("Object deserialized: " + obj);<br>    }<br>}<br>``` | ```java<br>import com.fasterxml.jackson.databind.ObjectMapper;<br>import javax.servlet.http.*;<br>import java.io.*;<br><br>public class SecureDeserializationServlet extends HttpServlet {<br>    private static final ObjectMapper mapper = new ObjectMapper();<br>    protected void doPost(HttpServletRequest request, HttpServletResponse response) <br>            throws ServletException, IOException {<br>        String json = new BufferedReader(new InputStreamReader(request.getInputStream())).readLine();<br>        // SECURE: Use JSON deserialization<br>        try {<br>            Object obj = mapper.readValue(json, Object.class);  // Safe parsing<br>            response.getWriter().println("Object deserialized: " + obj);<br>        } catch (Exception e) {<br>            response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Invalid data");<br>        }<br>    }<br>}<br>``` | - Avoid deserializing untrusted data with `pickle` or `ObjectInputStream`.<br>- Use safe formats like JSON.<br>- Implement class whitelisting if deserialization is necessary. |
| 3    | Insecure Direct Object Reference (IDOR) (CWE-639) | IDOR vulnerabilities occur when applications allow direct access to objects using user-supplied identifiers without authorization checks, enabling attackers to access unauthorized data or resources by manipulating inputs. | ```python<br>from flask import Flask, request, jsonify<br>import sqlite3<br><br>app = Flask(__name__)<br><br>@app.route('/user/<int:user_id>')<br>def vulnerable_get_user(user_id):<br>    # VULNERABLE: No auth check<br>    conn = sqlite3.connect('users.db')<br>    cursor = conn.cursor()<br>    cursor.execute("SELECT * FROM users WHERE id = ?", (user_id,))<br>    user = cursor.fetchone()<br>    # DANGER: Exposes sensitive data without verification<br>    if user:<br>        return jsonify({'id': user[0], 'name': user[1], 'email': user[2], 'ssn': user[3]})<br>    return "User not found", 404<br>``` | ```python<br>from flask import Flask, request, jsonify, session<br>from functools import wraps<br><br>app = Flask(__name__)<br>app.secret_key = 'secure-key'<br><br>def require_auth(f):<br>    @wraps(f)<br>    def decorated(*args, **kwargs):<br>        if 'user_id' not in session:<br>            return "Authentication required", 401<br>        return f(*args, **kwargs)<br>    return decorated<br><br>@app.route('/user/<int:user_id>')<br>@require_auth<br>def secure_get_user(user_id):<br>    current_user_id = session['user_id']<br>    # SECURE: Authorization check<br>    if user_id != current_user_id:<br>        return "Access denied", 403<br>    conn = sqlite3.connect('users.db')<br>    cursor = conn.cursor()<br>    cursor.execute("SELECT id, name, email FROM users WHERE id = ?", (user_id,))<br>    user = cursor.fetchone()<br>    if user:<br>        return jsonify({'id': user[0], 'name': user[1], 'email': user[2]})  # No SSN<br>    return "User not found", 404<br>``` | ```java<br>import javax.servlet.http.*;<br>import java.sql.*;<br><br>public class VulnerableUserController {<br>    protected void doGet(HttpServletRequest request, HttpServletResponse response) <br>            throws Exception {<br>        String id = request.getParameter("id");<br>        // VULNERABLE: No auth check<br>        Connection conn = DriverManager.getConnection("jdbc:sqlite:users.db");<br>        Statement stmt = conn.createStatement();<br>        ResultSet rs = stmt.executeQuery("SELECT * FROM users WHERE id = " + id);<br>        // DANGER: Exposes all data<br>        if (rs.next()) {<br>            response.getWriter().println("ID: " + rs.getString("id") + ", SSN: " + rs.getString("ssn"));<br>        }<br>    }<br>}<br>``` | ```java<br>import javax.servlet.http.*;<br>import java.sql.*;<br>import org.springframework.security.core.Authentication;<br><br>public class SecureUserController {<br>    protected void doGet(HttpServletRequest request, HttpServletResponse response) <br>            throws Exception {<br>        String id = request.getParameter("id");<br>        Authentication auth = SecurityContextHolder.getContext().getAuthentication();<br>        String currentUserId = auth.getName();<br>        // SECURE: Authorization check<br>        if (!currentUserId.equals(id)) {<br>            response.sendError(HttpServletResponse.SC_FORBIDDEN);<br>            return;<br>        }<br>        Connection conn = DriverManager.getConnection("jdbc:sqlite:users.db");<br>        PreparedStatement pstmt = conn.prepareStatement("SELECT id, name, email FROM users WHERE id = ?");<br>        pstmt.setString(1, id);<br>        ResultSet rs = pstmt.executeQuery();<br>        if (rs.next()) {<br>            response.getWriter().println("ID: " + rs.getString("id") + ", Name: " + rs.getString("name"));<br>        }<br>    }<br>}<br>``` | - Always verify user authorization before granting access.<br>- Avoid exposing sensitive fields unnecessarily.<br>- Use session-based checks to enforce ownership. |
| 4    | Insecure Session Identifier (CWE-330, CWE-384) | Predictable session IDs allow attackers to guess valid session identifiers, leading to session hijacking. This occurs when IDs are generated sequentially or with weak randomness, compromising user authentication. | ```python<br>import random<br>from flask import Flask, session, request<br><br>app = Flask(__name__)<br>app.secret_key = 'secret'<br>session_counter = 1000<br><br>@app.route('/login', methods=['POST'])<br>def vulnerable_login():<br>    username = request.form.get('username')<br>    password = request.form.get('password')<br>    if username == "admin" and password == "pass":<br>        global session_counter<br>        # VULNERABLE: Predictable session ID<br>        session['session_id'] = str(session_counter)<br>        session_counter += 1  # Sequential IDs<br>        return "Logged in"<br>    return "Invalid credentials"<br>``` | ```python<br>import secrets<br>from flask import Flask, session, request<br><br>app = Flask(__name__)<br>app.secret_key = secrets.token_hex(32)<br><br>@app.route('/login', methods=['POST'])<br>def secure_login():<br>    username = request.form.get('username')<br>    password = request.form.get('password')<br>    if username == "admin" and password == "pass":<br>        # SECURE: Cryptographically secure session ID<br>        session['session_id'] = secrets.token_urlsafe(32)<br>        session['username'] = username<br>        return "Logged in"<br>    return "Invalid credentials"<br>``` | ```java<br>import javax.servlet.http.*;<br>import java.util.Random;<br><br>public class VulnerableSessionServlet extends HttpServlet {<br>    private static int counter = 1000;<br>    protected void doPost(HttpServletRequest request, HttpServletResponse response) <br>            throws ServletException, IOException {<br>        String username = request.getParameter("username");<br>        if ("admin".equals(username)) {<br>            HttpSession session = request.getSession();<br>            // VULNERABLE: Predictable ID<br>            session.setAttribute("sessionId", String.valueOf(counter++));<br>            response.getWriter().println("Logged in");<br>        }<br>    }<br>}<br>``` | ```java<br>import javax.servlet.http.*;<br>import java.util.UUID;<br><br>public class SecureSessionServlet extends HttpServlet {<br>    protected void doPost(HttpServletRequest request, HttpServletResponse response) <br>            throws ServletException, IOException {<br>        String username = request.getParameter("username");<br>        if ("admin".equals(username)) {<br>            HttpSession session = request.getSession();<br>            // SECURE: Random UUID for session ID<br>            session.setAttribute("sessionId", UUID.randomUUID().toString());<br>            Cookie cookie = new Cookie("JSESSIONID", session.getId());<br>            cookie.setHttpOnly(true);  // Prevent XSS<br>            cookie.setSecure(true);    // HTTPS only<br>            response.addCookie(cookie);<br>            response.getWriter().println("Logged in");<br>        }<br>    }<br>}<br>``` | - Use cryptographically secure random generators for session IDs.<br>- Set secure cookie attributes (`HttpOnly`, `Secure`).<br>- Avoid sequential or predictable patterns. |
| 5    | Server-Side Request Forgery (SSRF) (CWE-918) | SSRF allows attackers to trick the server into making unauthorized requests, potentially accessing internal systems or services (e.g., localhost, metadata endpoints) by manipulating URL inputs. | ```python<br>import requests<br>from flask import Flask, request<br><br>app = Flask(__name__)<br><br>@app.route('/fetch_url', methods=['POST'])<br>def vulnerable_fetch_url():<br>    target_url = request.json.get('url')<br>    # VULNERABLE: No URL validation<br>    response = requests.get(target_url)  # Can access internal URLs<br>    return response.text<br>``` | ```python<br>import requests<br>from flask import Flask, request<br>from urllib.parse import urlparse<br><br>app = Flask(__name__)<br>ALLOWED_DOMAINS = {'api.example.com'}<br><br>@app.route('/fetch_url', methods=['POST'])<br>def secure_fetch_url():<br>    target_url = request.json.get('url')<br>    parsed = urlparse(target_url)<br>    # SECURE: Domain whitelist check<br>    if parsed.hostname not in ALLOWED_DOMAINS:<br>        return "Unauthorized URL", 403<br>    response = requests.get(target_url, timeout=5, allow_redirects=False)<br>    return response.text<br>``` | ```java<br>import javax.servlet.http.*;<br>import java.net.*;<br><br>public class VulnerableSSRFServlet extends HttpServlet {<br>    protected void doGet(HttpServletRequest request, HttpServletResponse response) <br>            throws Exception {<br>        String url = request.getParameter("url");<br>        // VULNERABLE: No validation<br>        URL target = new URL(url);<br>        HttpURLConnection conn = (HttpURLConnection) target.openConnection();<br>        // DANGER: Can fetch internal resources<br>        response.getWriter().write(new BufferedReader(new InputStreamReader(conn.getInputStream())).readLine());<br>    }<br>}<br>``` | ```java<br>import javax.servlet.http.*;<br>import java.net.*;<br>import java.util.Set;<br><br>public class SecureSSRFServlet extends HttpServlet {<br>    private static final Set<String> ALLOWED = Set.of("api.example.com");<br>    protected void doGet(HttpServletRequest request, HttpServletResponse response) <br>            throws Exception {<br>        String url = request.getParameter("url");<br>        URL target = new URL(url);<br>        // SECURE: Whitelist validation<br>        if (!ALLOWED.contains(target.getHost())) {<br>            response.sendError(HttpServletResponse.SC_FORBIDDEN);<br>            return;<br>        }<br>        HttpURLConnection conn = (HttpURLConnection) target.openConnection();<br>        conn.setInstanceFollowRedirects(false);  // Prevent bypass<br>        response.getWriter().write(new BufferedReader(new InputStreamReader(conn.getInputStream())).readLine());<br>    }<br>}<br>``` | - Validate URLs against a whitelist.<br>- Block internal IP ranges and redirect attempts.<br>- Limit request scope and response size. |
| 6    | Secrets Exposure (CWE-200, CWE-312, CWE-522) | Secrets exposure occurs when sensitive data (e.g., passwords, API keys) is hardcoded, improperly stored, or exposed, allowing attackers to gain unauthorized access or escalate privileges. | ```python<br>from flask import Flask<br><br>app = Flask(__name__)<br># VULNERABLE: Hardcoded secrets<br>API_KEY = "sk-1234567890"<br><br>@app.route('/api_call')<br>def vulnerable_api_call():<br>    # DANGER: Exposed in code<br>    headers = {'Authorization': f'Bearer {API_KEY}'}<br>    return "API called"<br>``` | ```python<br>import os<br>from flask import Flask<br><br>app = Flask(__name__)<br># SECURE: Environment variables<br>API_KEY = os.environ.get('API_KEY')<br><br>@app.route('/api_call')<br>def secure_api_call():<br>    if not API_KEY:<br>        return "Missing key", 500<br>    headers = {'Authorization': f'Bearer {API_KEY}'}<br>    return "API called"<br>``` | ```java<br>import javax.servlet.http.*;<br><br>public class VulnerableSecretsServlet extends HttpServlet {<br>    private static final String API_KEY = "sk-1234567890";  // VULNERABLE: Hardcoded<br>    protected void doGet(HttpServletRequest request, HttpServletResponse response) <br>            throws Exception {<br>        // DANGER: Exposed key<br>        response.getWriter().println("API Key: " + API_KEY);<br>    }<br>}<br>``` | ```java<br>import javax.servlet.http.*;<br><br>public class SecureSecretsServlet extends HttpServlet {<br>    private static final String API_KEY = System.getenv("API_KEY");  // SECURE: Env var<br>    protected void doGet(HttpServletRequest request, HttpServletResponse response) <br>            throws Exception {<br>        if (API_KEY == null) {<br>            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);<br>            return;<br>        }<br>        response.getWriter().println("API call made");<br>    }<br>}<br>``` | - Store secrets in environment variables or secure vaults.<br>- Avoid logging sensitive data.<br>- Use encryption for stored secrets. |
| 7    | SQL Injection (CWE-89)                 | SQL injection occurs when untrusted data is included in SQL queries, allowing attackers to manipulate the database, extract data, or execute malicious commands by altering query structure. | ```python<br>import sqlite3<br>from flask import Flask, request<br><br>app = Flask(__name__)<br><br>@app.route('/user')<br>def vulnerable_get_user():<br>    username = request.args.get('username')<br>    conn = sqlite3.connect('users.db')<br>    cursor = conn.cursor()<br>    # VULNERABLE: String concatenation<br>    query = f"SELECT * FROM users WHERE username = '{username}'"  # e.g., ' OR '1'='1<br>    cursor.execute(query)<br>    return str(cursor.fetchone())<br>``` | ```python<br>import sqlite3<br>from flask import Flask, request<br><br>app = Flask(__name__)<br><br>@app.route('/user')<br>def secure_get_user():<br>    username = request.args.get('username')<br>    conn = sqlite3.connect('users.db')<br>    cursor = conn.cursor()<br>    # SECURE: Parameterized query<br>    query = "SELECT * FROM users WHERE username = ?"<br>    cursor.execute(query, (username,))  # Safe binding<br>    return str(cursor.fetchone())<br>``` | ```java<br>import javax.servlet.http.*;<br>import java.sql.*;<br><br>public class VulnerableSQLServlet extends HttpServlet {<br>    protected void doGet(HttpServletRequest request, HttpServletResponse response) <br>            throws Exception {<br>        String username = request.getParameter("username");<br>        Connection conn = DriverManager.getConnection("jdbc:sqlite:users.db");<br>        Statement stmt = conn.createStatement();<br>        // VULNERABLE: Concatenation<br>        String query = "SELECT * FROM users WHERE username = '" + username + "'";<br>        ResultSet rs = stmt.executeQuery(query);  // e.g., ' OR '1'='1<br>        rs.next();<br>        response.getWriter().println(rs.getString("username"));<br>    }<br>}<br>``` | ```java<br>import javax.servlet.http.*;<br>import java.sql.*;<br><br>public class SecureSQLServlet extends HttpServlet {<br>    protected void doGet(HttpServletRequest request, HttpServletResponse response) <br>            throws Exception {<br>        String username = request.getParameter("username");<br>        Connection conn = DriverManager.getConnection("jdbc:sqlite:users.db");<br>        // SECURE: Prepared statement<br>        PreparedStatement pstmt = conn.prepareStatement("SELECT * FROM users WHERE username = ?");<br>        pstmt.setString(1, username);  // Safe binding<br>        ResultSet rs = pstmt.executeQuery();<br>        rs.next();<br>        response.getWriter().println(rs.getString("username"));<br>    }<br>}<br>``` | - Use parameterized queries or ORM frameworks.<br>- Validate and sanitize inputs before query execution.<br>- Limit database permissions. |
| 8    | Cross-Site Scripting (XSS) (CWE-79)    | XSS allows attackers to inject malicious scripts into web pages, executing in users' browsers to steal data, hijack sessions, or deface content, exploiting trust in the application. | ```python<br>from flask import Flask, request<br><br>app = Flask(__name__)<br><br>@app.route('/search')<br>def vulnerable_search():<br>    query = request.args.get('q', '')<br>    # VULNERABLE: No escaping<br>    return f"Search results for: {query}"  # e.g., alert('XSS')<br>``` | ```python<br>from flask import Flask, request, escape<br><br>app = Flask(__name__)<br><br>@app.route('/search')<br>def secure_search():<br>    query = request.args.get('q', '')<br>    # SECURE: HTML escaping<br>    return f"Search results for: {escape(query)}"  # Safe output<br>``` | ```java<br>import javax.servlet.http.*;<br><br>public class VulnerableXSSServlet extends HttpServlet {<br>    protected void doGet(HttpServletRequest request, HttpServletResponse response) <br>            throws Exception {<br>        String query = request.getParameter("q");<br>        // VULNERABLE: No escaping<br>        response.getWriter().println("Search: " + query);  // e.g., alert('XSS')<br>    }<br>}<br>``` | ```java<br>import javax.servlet.http.*;<br>import org.owasp.encoder.Encode;<br><br>public class SecureXSSServlet extends HttpServlet {<br>    protected void doGet(HttpServletRequest request, HttpServletResponse response) <br>            throws Exception {<br>        String query = request.getParameter("q");<br>        // SECURE: HTML escaping<br>        response.getWriter().println("Search: " + Encode.forHtml(query));  // Safe output<br>    }<br>}<br>``` | - Always escape user input based on output context (HTML, JS, etc.).<br>- Use sanitization libraries like OWASP Encoder or Bleach.<br>- Set `Content-Security-Policy` headers. |
| 9    | Client-Side Request Forgery (CSRF) (CWE-352) | CSRF tricks authenticated users into performing unintended actions by exploiting trust in their browser, such as submitting forms or making requests without their consent, often via malicious sites. | ```python<br>from flask import Flask, request, session<br><br>app = Flask(__name__)<br>app.secret_key = 'key'<br><br>@app.route('/transfer', methods=['POST'])<br>def vulnerable_transfer():<br>    if 'user' not in session:<br>        return "Login required", 401<br>    # VULNERABLE: No CSRF protection<br>    amount = request.form.get('amount')<br>    return f"Transferred {amount}"<br>``` | ```python<br>from flask import Flask, request, session<br>import secrets<br><br>app = Flask(__name__)<br>app.secret_key = secrets.token_hex(32)<br><br>def check_csrf(f):<br>    def wrapper(*args, **kwargs):<br>        token = request.form.get('csrf_token')<br>        if token != session.get('csrf_token'):<br>            return "CSRF failed", 403<br>        return f(*args, **kwargs)<br>    return wrapper<br><br>@app.route('/transfer', methods=['POST'])<br>@check_csrf<br>def secure_transfer():<br>    if 'user' not in session:<br>        return "Login required", 401<br>    # SECURE: CSRF token validated<br>    amount = request.form.get('amount')<br>    return f"Transferred {amount}"<br>``` | ```java<br>import javax.servlet.http.*;<br><br>public class VulnerableCSRFServlet extends HttpServlet {<br>    protected void doPost(HttpServletRequest request, HttpServletResponse response) <br>            throws Exception {<br>        HttpSession session = request.getSession();<br>        if (session.getAttribute("user") == null) {<br>            response.sendError(401);<br>            return;<br>        }<br>        // VULNERABLE: No CSRF check<br>        String amount = request.getParameter("amount");<br>        response.getWriter().println("Transferred: " + amount);<br>    }<br>}<br>``` | ```java<br>import javax.servlet.http.*;<br>import java.util.UUID;<br><br>public class SecureCSRFServlet extends HttpServlet {<br>    protected void doPost(HttpServletRequest request, HttpServletResponse response) <br>            throws Exception {<br>        HttpSession session = request.getSession();<br>        if (session.getAttribute("user") == null) {<br>            response.sendError(401);<br>            return;<br>        }<br>        String token = request.getParameter("csrf_token");<br>        // SECURE: Validate CSRF token<br>        if (!token.equals(session.getAttribute("csrf_token"))) {<br>            response.sendError(403, "CSRF validation failed");<br>            return;<br>        }<br>        String amount = request.getParameter("amount");<br>        response.getWriter().println("Transferred: " + amount);<br>    }<br>}<br>``` | - Implement CSRF tokens for state-changing requests.<br>- Use `SameSite` cookies to mitigate CSRF.<br>- Validate tokens securely with constant-time comparison. |
| 10   | XML External Entities (XXE) (CWE-611)  | XXE vulnerabilities allow attackers to manipulate XML parsers to access local files, perform SSRF, or cause denial-of-service by processing malicious XML input containing external entity references. | ```python<br>from xml.etree import ElementTree as ET<br>from flask import Flask, request<br><br>app = Flask(__name__)<br><br>@app.route('/parse', methods=['POST'])<br>def vulnerable_parse():<br>    xml = request.data<br>    # VULNERABLE: Default parser processes external entities<br>    tree = ET.fromstring(xml)  # Can read /etc/passwd<br>    return "Parsed"<br>``` | ```python<br>from defusedxml.ElementTree import parse<br>from flask import Flask, request<br><br>app = Flask(__name__)<br><br>@app.route('/parse', methods=['POST'])<br>def secure_parse():<br>    xml = request.data<br>    # SECURE: Defused parser disables entities<br>    tree = parse(xml, forbid_dtd=True, forbid_entities=True)<br>    return "Parsed"<br>``` | ```java<br>import javax.servlet.http.*;<br>import javax.xml.parsers.*;<br><br>public class VulnerableXXEServlet extends HttpServlet {<br>    protected void doPost(HttpServletRequest request, HttpServletResponse response) <br>            throws Exception {<br>        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();<br>        // VULNERABLE: Default settings allow XXE<br>        DocumentBuilder db = dbf.newDocumentBuilder();<br>        db.parse(request.getInputStream());  // Can access files<br>        response.getWriter().println("Parsed");<br>    }<br>}<br>``` | ```java<br>import javax.servlet.http.*;<br>import javax.xml.parsers.*;<br><br>public class SecureXXEServlet extends HttpServlet {<br>    protected void doPost(HttpServletRequest request, HttpServletResponse response) <br>            throws Exception {<br>        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();<br>        // SECURE: Disable external entities<br>        dbf.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);<br>        dbf.setFeature("http://xml.org/sax/features/external-general-entities", false);<br>        DocumentBuilder db = dbf.newDocumentBuilder();<br>        db.parse(request.getInputStream());<br>        response.getWriter().println("Parsed");<br>    }<br>}<br>``` | - Disable external entity processing in XML parsers.<br>- Use secure libraries like `defusedxml` in Python.<br>- Validate XML input structure before parsing. |

---

### Additional Notes
- **Code Comments**: Each code snippet includes inline comments to explain why the code is vulnerable or secure, enhancing understanding.
- **Markdown Formatting**: The table uses markdown for readability, with code blocks (` ``` `) for examples and bold headers for clarity.
- **Completeness**: All ten vulnerabilities align with the user’s request, including the inferred tenth vulnerability (XXE) based on references provided.
- **Ease of Understanding**: Descriptions are detailed yet concise, and code examples are simplified to focus on the vulnerability and its mitigation.

This table serves as a practical guide for developers to identify, understand, and prevent these critical web application security vulnerabilities effectively.